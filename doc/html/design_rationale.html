<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>STF: Design Rationale</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">STF
   &#160;<span id="projectnumber">0.0.1-1-g2f5b820 (pre-release)</span>
   </div>
   <div id="projectbrief">Simple TDD Framework</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('design_rationale.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Design Rationale </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#rationale-preface">Objectives</a></li>
<li class="level1"><a href="#rationale-ulp">Precision testing</a><ul><li class="level2"><a href="#rationale-ulp-metric">Metric for precision measurement</a></li>
<li class="level2"><a href="#rationale-ulp-distance">Computing ULP Distance</a></li>
<li class="level2"><a href="#rationale-ulp-tests">Taking ULP in consideration in your tests</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="rationale-preface"></a>
Objectives</h1>
<p>This section explains some of the Design choices made by STF on how to implement some of its components and how the usage of its macros was envisioned.</p>
<h1><a class="anchor" id="rationale-ulp"></a>
Precision testing</h1>
<blockquote class="doxtable">
<p>"Are these two floating computations results similar enough ?"" </p>
</blockquote>
<p>This is maybe the most difficult question to answer when implementing and validating numerical algorithms. Various methods are often found in existing testing frameworks or are used by developers. But, in the same way floating-point arithmetic can be tricky, floating-point comparisons are even trickier.</p>
<p>In the rest of this section, we take for granted that the basic notions of floating-point computations and their related problems is known by the reader. If not, we strongly recommend having a deep look at <a href="http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">Goldberg's paper on the subject</a> or to <a href="http://floating-point-gui.de/">its simplified version</a>.</p>
<h2><a class="anchor" id="rationale-ulp-metric"></a>
Metric for precision measurement</h2>
<p>The first thing people learn (and often they learn it the hard way) is that strict equality for floating points number is often meaningless or very hard to achieve. Once this state of fact is integrated, people often goes to use a simple absolute difference with an arbitrary threshold. If this method looks sound, it's easy to fold and may lead to false positive. The proper way to compare non-zero or non-invalid floating point numbers is to use the <em>Unit in the Last Place</em> metric.</p>
<p>Let us define \( \epsilon \) &ndash; the machine epsilon<a class="anchor" id="back1"></a><a href="#1"><sup>1</sup></a> &ndash; as being the smallest positive floating point number such that \( 1+\epsilon \) is different of \( 1 \) In fact, \( 1+\epsilon \) and \( 1 \) only differs by a bit 1 in the least significant digit: the unit in the last place (ULP). Generally, the ULP between a floating point number \(f\) and its immediate successor is \( \epsilon \times 2^{E} \) where \(E\) is the exponent of \(f\).</p>
<h2><a class="anchor" id="rationale-ulp-distance"></a>
Computing ULP Distance</h2>
<p>The ULP distance (or <code>ulpdist</code>) is a way to compare floating-point numbers by estimating the number of significant bits between their respective representations. The IEEE 754 specification &ndash; followed by all modern floating-point hardware &ndash; requires that the result of an elementary arithmetic operation (addition, subtraction, multiplication, division, and square root) must be within 0.5 ULP of the mathematically exact result. Achieving 0.5-1 ULP for computationally complex functions like transcendental functions is what a proper numerical library should aim for.</p>
<p>The full algorithm can be expressed in standard C++ in the following way:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keywordtype">double</span> <a class="code" href="group__group-details_gae2a5fd731b4e32c351f0adcd3a9deb61.html#gae2a5fd731b4e32c351f0adcd3a9deb61">ulpdist</a>(T a0, T a1)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Exit if a0 and a1 are equal or both NaN</span></div>
<div class="line">  <span class="keywordflow">if</span>( (a0 == a1) || ((a0!=a0) &amp;&amp; (a1!=a1)) )</div>
<div class="line">    <span class="keywordflow">return</span> 0.;</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">int</span> e1,e2;</div>
<div class="line">  T   m1,m2;</div>
<div class="line">  m1 = std::frexp(a0, &amp;e1);</div>
<div class="line">  m2 = std::frexp(a1, &amp;e2);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Compute the largest exponent between arguments</span></div>
<div class="line">  <span class="keywordtype">int</span> expo = std::max(e1, e2);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Properly normalize the two numbers by the same factor in a way that the largest of the two numbers exponents will be brought to zero</span></div>
<div class="line">  T n1 = std::ldexp(a0, -expo);</div>
<div class="line">  T n2 = std::ldexp(a1, -expo);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Compute the absolute difference of the normalized numbers</span></div>
<div class="line">  T e = (e1 == e2) ? std::abs(m1-m2) : std::abs(n1-n2);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Return the distance in ULP by diving this difference by the machine epsilon</span></div>
<div class="line">  <span class="keywordflow">return</span> double(e/std::numeric_limits&lt;T&gt;::epsilon());</div>
<div class="line">}</div>
</div><!-- fragment --><p> Put in an other way, one can estimate the <code>ulpdist</code> between two floating point numbers as the number of representable floating points values between them. This estimation leads to the following properties:</p>
<ul>
<li>The <code>ulpdist</code> between \(N\) and \(N+N\times\epsilon\) is equal to \(0.5\)</li>
<li>The <code>ulpdist</code> between \(N\) and \(N+N\times\frac{\epsilon}{2}\) is equal to \(0\)</li>
<li>If a <code>double</code> is compared to the double representation of its single precision conversion (they are exceptions as for fully representable reals), their <code>ulpdist</code> will be around \(2^{26.5}\) (or \(10^8\)).</li>
</ul>
<p>For example: <code>ulpdist( double(float(M_PI)), double(M_PI) ) == 9.84293e+07</code></p>
<h2><a class="anchor" id="rationale-ulp-tests"></a>
Taking ULP in consideration in your tests</h2>
<p>What to do then when writing an unit test that handles floating points number ? You basically have three cases :</p>
<ul>
<li>The value you compare must be equal by design. In this case, use <a class="el" href="group__group-unit_ga4b2b3405756de40ff18c63dcfca96565.html#ga4b2b3405756de40ff18c63dcfca96565">STF_EQUAL</a> to clearly state your intent. One such case can be for example functions that construct a floating point value bitwise.</li>
<li>The value you compare are the results of an undetermined number of other floating point operations. In this case, use <a class="el" href="group__group-unit_ga1cc6ace11e8e94837176bb7198507f80.html#ga1cc6ace11e8e94837176bb7198507f80">STF_ULP_EQUAL</a> and try to estimate the maximum amount of ULP your implementation should give. This can be either done by a strict analysis of the function behavior or by some guess work.</li>
<li>The value you compare are the results of an undetermined number of other floating point operations but stands in a predictable absolute range of error independent of the architecture and magnitude of the input. In this case, use <a class="el" href="group__group-unit_gaffd9c8cb6366f79c10b85bda07b92f16.html#gaffd9c8cb6366f79c10b85bda07b92f16">STF_RELATIVE_EQUAL</a>.</li>
</ul>
<p>Take extreme care to not overestimate the value of ULP measures. Some classical algorithms may ends up with hundreds of ULPs but still be meaningful. </p><hr/>
<p><a class="anchor" id="1"></a>[<a href="#back1">1</a>]: \(\epsilon\) is \(2^{-52}\) for double precision numbers and \(2^{-23}\) for single precision numbers. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
